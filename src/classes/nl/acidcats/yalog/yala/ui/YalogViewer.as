/*Copyright 2009 Stephan Bezoen, http://stephan.acidcats.nlLicensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License at   	http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License.*/package nl.acidcats.yalog.yala.ui {	import fl.controls.ScrollBar;		import nl.acidcats.yalog.common.Functions;	import nl.acidcats.yalog.common.Levels;	import nl.acidcats.yalog.common.MessageData;	import nl.acidcats.yalog.yala.datafilter.IDataFilter;	import nl.acidcats.yalog.yala.datafilter.LevelFilter;	import nl.acidcats.yalog.yala.ui.table.RowRenderer;	import nl.acidcats.yalog.yala.ui.table.Table;	import nl.acidcats.yalog.yala.util.connection.ReceiverConnection;	import nl.acidcats.yalog.yala.util.connection.ReceiverConnectionEvent;	import nl.acidcats.yalog.yala.util.scroll.Scroller;		import flash.display.DisplayObjectContainer;	import flash.display.Sprite;	import flash.events.EventDispatcher;	import flash.events.StatusEvent;	import flash.events.TimerEvent;	import flash.net.LocalConnection;	import flash.system.System;	import flash.utils.Timer;	import flash.utils.getQualifiedClassName;	import flash.utils.getTimer;		public class YalogViewer extends EventDispatcher {		// Time in seconds between each rendering		private static const UPDATE_TIME : Number = 0.1;		private var mContainer : DisplayObjectContainer;		private var mTable : Table;		private var mScrollBar : ScrollBar;		private var mScroller : Scroller;		private var mReceiver : ReceiverConnection;		private var mTransmitter : LocalConnection;		private var mReceivedMessageCount : Number = 0;		private var mTimer : Timer;		private var mIsPaused : Boolean = false;		private var mIsConnected : Boolean;		public function YalogViewer (inContainer : DisplayObjectContainer, inWidth : Number, inHeight : Number) {			super();						mContainer = inContainer;						initUI(inWidth, inHeight);		}				/**		 *	Start the transmitter & receiver connection		 */		public function connect () : void {			initReceiver();			initTransmitter();		}				/**		 *		 */		public function clear () : void {			mTable.clear();						mScroller.update();		}				/**		 * Toggle display update 		 */		public function pause () : void {			if (mIsPaused) {				if (mIsConnected) dispatchEvent(new YalogViewerStatusEvent(YalogViewerStatusEvent.INACTIVE));				mTimer.start();			} else {				dispatchEvent(new YalogViewerStatusEvent(YalogViewerStatusEvent.PAUSED));				mTimer.stop();			}			mIsPaused = !mIsPaused;		}				/**		 *		 */		public function setScrollBar (inScrollBar : ScrollBar) : void {			mScrollBar = inScrollBar;						// create link between table & scrollbar			mScroller = new Scroller(mTable, inScrollBar);			mScroller.setScrollToEnd(true);		}				/**		 *		 */		public function setSize (inWidth : Number, inHeight : Number) : void {			// resize and update the table			mTable.setSize(inWidth, inHeight);			mTable.update();			mScrollBar.height = inHeight;			mScrollBar.x = inWidth - mScrollBar.width;			mScroller.update();		}				/**		 *		 */		public function addFilter (inFilter : IDataFilter) : void {			mTable.addFilter(inFilter);						update();		}				/**		 *		 */		public function removeFilter (inFilter : IDataFilter) : void {			mTable.removeFilter(inFilter);						update();		}				/**		 *	Update the table after a filter has been changed		 */		public function update () : void {			mTable.update(true);			mScroller.update();		}				/**		 *	Copy content of table to clipboard		 */		public function copyDataToClipboard () : void {			var s : String = "";			var items : Array = mTable.data;						var len : Number = items.length;			for (var i : Number = 0;i < len; i++) {				var md : MessageData = MessageData(items[i]);				s += md.toString() + "\n";			}						System.setClipboard(s);		}				private function initUI (inWidth : Number, inHeight : Number) : void {			var s : Sprite = new Sprite();			mContainer.addChild(s);						// create table			mTable = new Table(s, RowRenderer, 14, inWidth, inHeight);			// ignore status messages			mTable.addFilter(new LevelFilter(Levels.STATUS));					}		/**		 * Initialize receiving LocalConnection		 */		private function initReceiver () : void {			// create the receiver connection, and allow any domain			mReceiver = new ReceiverConnection();						var receiverConnected : Boolean = false;			try {				receiverConnected = true;				mReceiver.connect(Functions.CHANNEL);			} catch (e : ArgumentError) {				receiverConnected = false;			}						if (!receiverConnected) {				// display error message				addMessage(new MessageData("-- CONNECTION FAILED --", Levels.ERROR));				mTable.update();								// show we have an error				dispatchEvent(new YalogViewerStatusEvent(YalogViewerStatusEvent.ERROR));				return;			}						// start listening to events			mReceiver.addEventListener(ReceiverConnectionEvent.PING_RECEIVED, handlePing);			mReceiver.addEventListener(ReceiverConnectionEvent.DATA_RECEIVED, handleDataReceived);						// display success			addMessage(new MessageData("-- CONNECTED --", Levels.INFO));						startUpdateTimer();						mIsConnected = true;						dispatchEvent(new YalogViewerStatusEvent(YalogViewerStatusEvent.CONNECTED));			dispatchEvent(new YalogViewerStatusEvent(YalogViewerStatusEvent.INACTIVE));		}				/**		 * Initialize LocalConnection to pong any present applications		 */		private function initTransmitter () : void {			mTransmitter = new LocalConnection();			mTransmitter.addEventListener(StatusEvent.STATUS, handleTransmitterStatusEvent);			for (var i : Number = 1;i < Functions.MAX_CHANNEL_COUNT; i++) {				mTransmitter.send(Functions.CHANNEL_PING + i, Functions.FUNC_PONG);			}		}				/**		 *	Add a message to the stack.		 *	@param inMessage: a block of data for rendering		 */		private function addMessage (inMessage : MessageData) : void {			// check if message contains newlines			var messList : Array = splitMessage(inMessage);						var len : Number = messList.length;						for (var i : Number = 0;i < len; i++) {				// store the message				mTable.addData(MessageData(messList[i]));								// update the counter				mReceivedMessageCount++;			}				// show we have activity			dispatchEvent(new YalogViewerStatusEvent(YalogViewerStatusEvent.ACTIVE));		}				/**		 *	Start the timer for regular updates of the table		 */		private function startUpdateTimer () : void {			mTimer = new Timer(1000 * UPDATE_TIME, 0);			mTimer.addEventListener(TimerEvent.TIMER, handleUpdateTimer);			mTimer.start();		}				/**		 *	Handle timer event by updating the table		 */		private function handleUpdateTimer (e : TimerEvent) : void {			if (mReceivedMessageCount > 0) {								// update the table				mTable.update();								// update the scroll bar				mScroller.update();				// reset the counter				mReceivedMessageCount = 0;					// reset the led				dispatchEvent(new YalogViewerStatusEvent(YalogViewerStatusEvent.INACTIVE));			}		}				/**		 * Handle event from LocalConnection that a 'ping' has been received from an external application		 */				private function handlePing (e : ReceiverConnectionEvent) : void {			addMessage(new MessageData("Ping received on channel '" + e.channel + "'", Levels.STATUS, getTimer(), toString()));			addMessage(new MessageData("--" + ": NEW LOG STARTED @ " + getRealTime() + " --", Levels.INFO));			try {				mTransmitter.send(e.channel, Functions.FUNC_PONG);			} catch (error:Error) {			}		}				/**		 * Handle event from LocalConnection that data has been received		 */		private function handleDataReceived (e : ReceiverConnectionEvent) : void {			addMessage(e.data);		}				/**		 * Handle status events form sender connection		 */		private function handleTransmitterStatusEvent (e : StatusEvent) : void {		}		/**		 *	Return a string containing the current time		 */		private function getRealTime () : String {			var d : Date = new Date();						return formatNumber(d.getHours()) + ":" + formatNumber(d.getMinutes()) + "." + formatNumber(d.getSeconds());		}				private function formatNumber (inNumber:Number) : String {			return (inNumber < 10) ? "0" + inNumber : "" + inNumber;		}				/**		 *	Split message into several messages if message contains newline		 *	@param inMessage: the message		 *	@return an Array of objects of type MessageData		 */		private function splitMessage (inMessage : MessageData) : Array {			var a : Array = new Array();			if (inMessage.text.indexOf("\n") > -1) {				var stringList : Array = inMessage.text.split("\n");				var len : Number = stringList.length;				for (var i : Number = 0;i < len; i++) {					var newText : String = stringList[i];					// add new messages, set time only for first message, sender only for last message					var newMessage : MessageData = new MessageData(newText, inMessage.level, (i == 0) ? inMessage.time : null, (i < len - 1) ? null : inMessage.sender);					a.push(newMessage);				}			} else {				a.push(inMessage);			}						return a;		}				override public function toString():String {			return getQualifiedClassName(this);		}			}}